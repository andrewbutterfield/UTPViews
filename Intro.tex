\section{Introduction}\label{sec:intro}

We now give a proper presentation of our UTP theory
of concurrent programming, looking at both the condition-free command language
of the Views paper\cite{conf/popl/Dinsdale-YoungBGPY13},
as well as the more complete language covered in the UTPP paper\cite{DBLP:conf/icfem/WoodcockH02}.
in UTP.

All references in bold to things
like \textbf{Definition 9} or \textbf{Parameter E} refer to corresponding material
in the Views paper.
The generic definitions from\cite{conf/popl/Dinsdale-YoungBGPY13}
are in Appendix \ref{sec:viewdefs}.

\subsection{The Language Menagerie}

Both languages are concurrent with shared state.
The most abstract is the Command language from \cite{conf/popl/Dinsdale-YoungBGPY13}:
\[
 C ::= a \mid \cskip \mid C \cseq C \mid C \parallel C \mid C+C \mid C^*
\]
with non-deterministic choice and iteration.
Note that we use $\cseq$ and $+$ for sequential composition
and non-deterministic choice in the Command language,
rather than the $;$ and $\sqcap$ of UTP,
because their semantics do not coincide.
Unlike in the standard theory of Designs as applied to sequential programs,
concurrent versions of these constructs do not match the relational
calculus forms.


The language from \cite{DBLP:conf/icfem/WoodcockH02} replaces both
non-deterministic constructs by deterministic ones depending
on a condition over shared-state:
\[
 D ::= a \mid \cskip \mid D \cseq D \mid D \parallel D \mid D \dcond c D \mid c \ddo D
\]
We will also consider Process Modelling Language
(PML)\cite{DBLP:journals/infsof/AtkinsonWN07},
which is like the Views command language except that atomic actions
have a state-based guard:
\[
 M ::= c \pgrd a \mid M \cseq M \mid M \parallel M \mid M+M \mid M^*
\]
A key point to note is that the semantics of common constructs is the same
in every language.
We also note that for $M$ we can merge the guard with the state-change,
as a conjuction, so $c \pgrd a$ in $M$ corresponds to an atomic
action of the form $c \land a$ in $D$.
Given this observation we shall define a single semantics over
a universal concurrent programming language:
\[
 P ::= a \mid \cskip \mid P \cseq P  \mid P \parallel P
   \mid P+P\mid P^*
   \mid P \dcond c P \mid c \ddo P
\]
where $c \pgrd a$ is simply sugar for $c \land a$.

PML maps into $M$ the obvious way,
with
\begin{verbatim}
action A {
  requires { rr }
  provides { pr }
}
\end{verbatim}
turning into atomic action
\[
rr \subseteq rs ~~\pgrd~~ rs' = rs \cup pr
\]
Here the program state (formerly denoted by $s$)
has turned into $rs:\power Res$, where $Res$ is the type of resources.
