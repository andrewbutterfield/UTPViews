\section{Commands}\label{sec:commands}



\subsection{Syntax}

\begin{eqnarray*}
   a &:& \mbox{Predicate, alphabet }s,s'
\\ c &:& \mbox{Predicate, alphabet }s
\end{eqnarray*}

\RLEQNS{
   P &::= & a             & \mbox{Atomic Action}
\\   &\mid& \cskip        & \mbox{No state change}
\\   &\mid& P \cseq P     & \mbox{Sequential Composition}
\\   &\mid& P \parallel P & \mbox{Parallel Composition}
\\   &\mid& P+P           & \mbox{Non-deterministic Choice}
\\   &\mid& P^*           & \mbox{Non-deterministic Iteration}
\\   &\mid& P \dcond c P  & \mbox{Conditional Choice}
\\   &\mid& c \ddo P      & \mbox{Conditional Iteration}
}

\subsection{Domains}
\begin{eqnarray*}
   s &\in& \mathcal S
\\ g &:& Gen
\\ \ell &:& Gen \fun Lbl
\\ G \in Gen &::=&  g \mid G_{:} \mid G_1 \mid G_2
\\ L \in Lbl &::=& \ell_G
\end{eqnarray*}

\subsection{Alphabet}

\begin{eqnarray*}
   s, s' &:& \mathcal S
\\ ls, ls' &:& \mathcal P (Lbl)
\\ g &:& Gen
\\ in, out &:& Lbl
\end{eqnarray*}
We assume a general notion of expressions ($e$)
and say that an expression $e$ is ``ground''
if it's free variables are limited to only $g$, $in$ and $out$.



\subsection{``Standard'' UTP Constructs}

\RLEQNS{
   P \cond C Q
   &\defs&
   C \land P \lor \lnot C \land Q
   & \elabel{UTP-cond-def}
\\ \Skip
   &\defs&
   s'= s \land ls'=ls
   & \elabel{UTP-skip-def}
\\ P \seq Q
   &\defs& \exists s_m,ls_m \bullet
\\ && \qquad P[s_m,ls_m/s',ls'] \land Q[s_m,ls_m/s,ls]
   & \elabel{UTP-seq-def}
\\ C * P
   &=&
   P ; C * P \cond C \Skip
   & \elabel{UTP-loop-unroll}
}
We also define a specialised form of sequential composition
to be used when neither component refers to $ls$ or $ls'$,
and its unit:
\RLEQNS{
   P \seq_s Q
   &\defs&
   \exists s_m \bullet P[s_m/s'] \land Q[s_m/s]
   & \elabel{UTP-s-seq-def}
\\ ii &\defs& s'=s & \elabel{ii-def}
}
We often omit the $s$ subscript when its use is clear from context.


\subsection{Shorthands}

\RLEQNS{
   ls(\ell) &\defs& \ell \in ls
\\ ls(L) &\defs& L \subseteq ls
\\ ls(\B\ell) &\defs& \ell \notin ls
\\ ls(\B L) &\defs& L \cap ls = \emptyset
}

\subsection{Semantic Concepts}

\subsubsection{Basic Action}

\RLEQNS{
   A(E|a|N)
   &\defs&
   ls(E) \land a \land ls'=(ls\setminus E) \cup N
   & \elabel{A-def}
}


\subsubsection{Wheels-within-Wheels}

\RLEQNS{
   \W(P) &\defs& \true * (\Skip \lor P) &\elabel{W-as-loop}
\\       &  =  & \bigvee_{i \in 0,\dots} \Skip \seq P^i &\elabel{W-as-NDC}
}

\subsubsection{Label-Set Invariant}

We want to be able to specify that certain combinations
of labels should never appear simultaneously
in the global label set ($ls$).
We do this by defining a label-set invariant $I$
which has alphabet $ls,in,out,g$.

We start by defining a general abstract way of specifying
sets with valid combinations
of values drawn from a parameter type $\tau$.
\RLEQNS{
   i \in I_\tau &::=& \tau   &  \mbox{can contain this value}
\\ &\mid& \otimes(i,\ldots,i) & \mbox{at most one of these allowed to contain}
\\ &\mid& \cup (i,\ldots,i) & \mbox{any of these allowed to contain}
}

We define what it means for an atomic action invocation
to satisfy an invariant parameterised on the label type ($Lbl$).
\RLEQNS{
  ls \textbf{ lsat } I \land A(E|a|N) &\implies& ls' \textbf{ lsat } I
}
We can re-formulate this as a following equivalent test:
\RLEQNS{
   A(E|a|N) \textbf{ sat } I_{Lbl}
   &\defs&
   E \textbf{ lsat } I_{Lbl} \land N \textbf{ lsat } I_{Lbl}
}
In effect we identify the occurrences of labels within this $I$-structure,
and then check the multiplicity constraints:
\RLEQNS{
   L \textbf{ lsat } I_{Lbl} &\defs& res=ok
\\ \textbf{where} && (res,\_) = occChk (occ_L I_{Lbl})
}
The $occ$ function takes a set $L$ of $\tau$ and an $I_\tau$ and returns a $I_\Bool$
that records if the corresponding element of $\tau$ is present in $L$.
\RLEQNS{
   occ &:& \power \tau \fun I_\tau \fun I_\Bool
\\ occ_L~\ell &\defs& \ell \in L
\\ occ_L~\otimes(i_1,\ldots,i_n)
   &\defs&
   \otimes(occ_L~i_1,\ldots,occ_L~i_n)
\\ occ_L~\cup(i_1,\ldots,i_n)
   &\defs&
   \cup(occ_L~i_1,\ldots,occ_L~i_n)
}
The $occChk$ function pattern matches across the boolean values to see if
constraints are satisfied.
The first component of the result is an overall ok/fail indicator,
while the second boolean component indicates if values are present
in any component.
\RLEQNS{
   occChk &:& I_\Bool \fun (\setof{ok,fail}\times \Bool)
\\ occChk(b) &\defs& (ok,b)
\\ occChk(\cup(i_1,\ldots,i_n))
   &\defs&
   (fail,\_),
   \textbf{ if }\exists j @ occChk(i_j) = (fail,\_)
\\ && (ok,b_1 \lor \dots \lor b_n),
   \textbf{ if }\forall j @ occChk(i_j) = (ok,b_j)
\\ occChk(\otimes(i_1,\ldots,i_n))
   &\defs&
   (fail,\_),
   \textbf{ if }\exists j @ occChk(i_j) = (fail,\_)
\\&& (fail,\_) \mbox{ if more than one $(ok,true)$}
\\&& (ok,false) \mbox{ if all are $(ok,false)$}
\\&& (ok,true) \mbox{ if  exactly one $(ok,true)$}
}
We note, as a consequence of the above definitions, that
\RLEQNS{
  \emptyset &  \textbf{lsat} &  I & \elabel{emp-lsat-I}
}
for any label-set invariant $I$.


Shorthand: $\otimes \mapsto |$, $\cup \mapsto ,$
\RLEQNS{
  ~ [ a,b,c | d,e | f ]
   &=&
   \otimes(\cup(a,b,c),\cup(d,e),f)
\\ ~[ a | (b|c),(d|e) | f ]
  &=&
  \otimes(a,\cup(\otimes(b,c),\otimes(d,e)),f)
}
We also have a shorthand that just denotes
the non-intersecting nature of the arguments.
E.g.,
$\setof{A|B|C}$ asserts that $A$, $B$ and $C$ are mutually disjoint,
without any reference to $ls$ or any other set.

\subsubsection{Invariant Examples}

The following examples show how various instances of $I$
get expanded when we consider the assertion:
$ls \textbf{ lsat } I $.

\RLEQNS{
   ls \textbf{ lsat } [in|out]
   &=&
   \setof{in} \cap \setof{out} = \emptyset
\\ &\land&
  \setof{in} \subseteq ls \implies \setof{out}\cap ls = \emptyset
\\ &\land&
  \setof{out} \subseteq ls \implies \setof{in}\cap ls = \emptyset
\\ ls \textbf{ lsat } [in|\ell|out]
   &=&
   \setof{in} \cap \setof{\ell} = \emptyset
\\ &\land&
   \setof{in} \cap \setof{out} = \emptyset
\\ &\land&
   \setof{\ell} \cap \setof{out} = \emptyset
\\ &\land&
  \setof{in} \subseteq ls \implies \setof{\ell,out}\cap ls = \emptyset
\\ &\land&
  \setof{\ell} \subseteq ls \implies \setof{in,out}\cap ls = \emptyset
\\ &\land&
  \setof{out} \subseteq ls \implies \setof{in,\ell}\cap ls = \emptyset
}

\RLEQNS{
   ls \textbf{ lsat } [ a | (b|c),(d|e) | f ]
   &=&
   \setof{a} \cap \setof{b,c,d,e,f} = \emptyset
\\ &\land&
   \setof{b,c,d,e} \cap \setof{a,f} = \emptyset
\\ &\land&
   \setof{f} \cap \setof{a,b,c,d} = \emptyset
\\ &\land&
  \setof{a} \subseteq ls \implies \setof{b,c,d,e,f}\cap ls = \emptyset
\\ &\land&
  \setof{b,c,d,e} \subseteq ls \implies \setof{a,f}\cap ls = \emptyset
\\ &\land&
  \setof{f} \subseteq ls \implies \setof{a,b,c,d,e}\cap ls = \emptyset
\\ &\land&
   \setof{b} \cap \setof{c} = \emptyset
\\ &\land&
   \setof{d} \cap \setof{e} = \emptyset
\\ &\land&
  \setof{b} \subseteq ls \implies \setof{c}\cap ls = \emptyset
\\ &\land&
  \setof{c} \subseteq ls \implies \setof{b}\cap ls = \emptyset
\\ &\land&
  \setof{d} \subseteq ls \implies \setof{e}\cap ls = \emptyset
\\ &\land&
  \setof{e} \subseteq ls \implies \setof{d}\cap ls = \emptyset
}
Here one of $b$ or $c$ may occur in $ls$ along with one of  $d$ or $e$.


\newpage
\subsection{Program Semantics}

In this semantics, we interpret any invariant
written as $I = [\dots|\dots|\dots]$
as shorthand for $ls \textbf{ lsat } I$.

\subsubsection{Atomic Action}

\RLEQNS{
  a &\defs& [in|out] \land \W(A(in|a|out)) & \elabel{sem:atomic}
\\ &=&  [in|out] \land (\Skip \lor A(in|a|out))
        & \elabel{nf-atomic}
}


\subsubsection{Guarded Atomic Action}
In effect there is no real difference between $c \pgrd a$
and $\true \pgrd (c \land a)$,
so in fact we don't need guarded actions as basic.
This is an advantage of treating the atomic action as a relational predicate
on state.

\RLEQNS{
 c \pgrd a &\defs& c \land a \mbox{ ---interpreted as atomic action} &\elabel{sem:pgrd}
}


\subsubsection{Skip}

\RLEQNS{
   ii     &\defs& s'=s
\\ \cskip &\defs& ii \mbox{ ---interpreted as atomic action} &\elabel{sem:skip}
\\  &=&  [in|out] \land (\Skip \lor A(in|ii|out))
}

\subsubsection{Sequential Composition}

\RLEQNS{
   P \cseq Q
   &\defs&
   [in|\ell_g|out]\land \W(P[g_{:1},\ell_g/g,out] \lor Q[g_{:2},\ell_g/g,in])
   & \elabel{sem:seq}
}

\subsubsection{Parallel Composition}

\RLEQNS{
   P \parallel Q
   &\defs&
   [in|(\ell_{g1}|\ell_{g1:}),(\ell_{g2}|\ell_{g2:})|out] \land {}
   & \elabel{sem:par}
\\&& \W(\quad\phlor A(in|ii|\ell_{g1},\ell_{g2})
\\ && \qquad {}\lor
   P[g_{1::},\ell_{g1},\ell_{g1:}/g,in,out]
\\ && \qquad {}\lor
    Q[g_{2::},\ell_{g2},\ell_{g2:}/g,in,out]
\\ && \qquad {}\lor
   A(\ell_{g1:},\ell_{g2:}|ii|out)~)
}


\subsubsection{Nondeterministic Choice}

\RLEQNS{
   P + Q
   &\defs&
   [in|\ell_{g1}|\ell_{g2}|out] \land {}
   & \elabel{sem:NDC}
\\ && \W(\quad {}\phlor A(in|ii|\ell_{g1})
\\ && \qquad {} \lor
                     A(in|ii|\ell_{g2})
\\ && \qquad {} \lor
   P[g_{1:},\ell_{g1}/g,in]
\\ && \qquad {} \lor
   Q[g_{2:},\ell_{g2}/g,in]~)
}

\subsubsection{Nondeterministic Loop}


\RLEQNS{
   P^*
   &\defs&
   [in|\ell_g|out] \land {}
   & \elabel{sem:star}
\\ && \W(\quad  \phlor A(in|ii|out)
\\ && \qquad {}\lor A(in|ii|\ell_g)
\\ && \qquad {}\lor P[g_{:},\ell_g,in/g,in,out]~)
}

\subsubsection{Conditional Choice}

\RLEQNS{
   P \dcond c Q
   &\defs&
   [in|\ell_{g1}|\ell_{g2}|out] \land {}
   & \elabel{sem:cond}
\\ && \W(\quad {}\phlor A(in|c \land ii|\ell_{g1})
\\ && \qquad {} \lor
                     A(in|\lnot c \land ii|\ell_{g2})
\\ && \qquad {} \lor
   P[g_{1:},\ell_{g1}/g,in]
\\ && \qquad {} \lor
   Q[g_{2:},\ell_{g2}/g,in]~)
}

\subsubsection{Conditional Loop}


\RLEQNS{
   c \ddo P
   &\defs&
   [in|\ell_g|out] \land {}
   & \elabel{sem:iter}
\\ && \W(\quad  \phlor A(in|\lnot c \land ii|out)
\\ && \qquad {}\lor A(in|c \land ii|\ell_g)
\\ && \qquad {}\lor P[g_{:},\ell_g,in/g,in,out]~)
}


\newpage
\subsection{Semantic Calculations}

\subsubsection{Normal Form}

All the semantics above have an invariant $I$,
zero or more atomic actions ($A_i$),
plus zero or more language sub-component predicates ($P_j$)
assembled into a predicate of the form:
\[
  I
  \land
  \W( A_1 \lor \dots \lor A_m
     \lor
     P_1\sigma_1 \lor \dots \lor P_n\sigma_n )
\]
where each $\sigma_i = [G_i,I_i,O_i/g,in,out]$,
with all $G_i$, $I_i$ and $O_i$ being ground
and satisfying the invariant $[I_i|labs(G_i)|O_i]$.
Given that we have
\[
  \W(P) = \bigvee_{i \in 0\dots} \Skip \seq P^i
\]
we find that two key outcomes result:
\begin{enumerate}
  \item
    Every program can be transformed,
    in principle at least,
    to the form
    \[
     I \land \left( \Skip \lor \bigvee_{i \in 0\dots}  A(E_i|a_i|N_i) \right)
    \]
    for suitable choices of $E_i$, $a_i$ and $N_i$.
    In particular, we find that the $E_i$ all satisfy the relevant
    label-set invariants.
    The invariant $I$ here is the conjunction of all the invariants
    from each level down, under the relevant substitutions.
  \item
    For any complete program that does not use iteration constructs,
    this expansion is finite.
\end{enumerate}
This can be sown by an inductive argument over the language syntax,
noting that the sequential composition of two such forms
can itself be transformed into such a form.
In effect this defines a \emph{normal form} for our semantics.

It is important to stress that these normal forms depend crucially
on the relevant label-set invariants holding throughout.

An important law we shall require is that the UTP sequential
composition of two normal forms can itself be expressed
as such a normal form:
\RLEQNS{
   I \land (\Skip\lor\bigvee A_i) \seq J \land (\Skip\lor\bigvee B_j)
   &=&
   I \land J \land (\Skip\lor\bigvee (A_i \seq B_j))
   &\elabel{nf-seq}
}
This is an easy result of the fact that $\seq$ distributes through $\lor$,
and $\Skip$ is a unit for it as well.


We now present calculations of normal forms for every language
construct, given atomic sub-components.
For ease of reading,
we display the invariant $I$ on the first line,
followed by the list of $A(\dots)$ disjuncts, perhaps several on a line,
as follows
\RLEQNS{
   res &=& I
\\ && A(E_1|a_1|N_1) \quad A(E_1|a_2|N_2)) \quad \dots
}
We omit parentheses or logical operators.
In general we try to put all the single atomic steps on the first line,
with all the mumblings on lower lines.

\subsubsection{Atomic Actions}
\RLEQNS{
   a &=& [in|out]
\\ && A(in|a|out)
\\
\\ \cskip &=& [in|out]
\\ && A(in|ii|out)
}

\subsubsection{Sequential Composition}
\RLEQNS{
   a \cseq b
   &=& [in|\ell_g|out]
\\ && A(in|a|\ell_g)\quad  A(\ell_g|b|out)
\\ && A(in|a\seq b|out)
}

\subsubsection{Non-deterministic Choice}
\RLEQNS{
   a + b
   &=& [in|\ell_{g1}|\ell_{g2}|out]
\\ &&  A(in|ii|\ell_{g1}) \quad A(in|ii|\ell_{g2})
       \quad
       A(\ell_{g1}|a|out) \quad A(\ell_{g2}|b|out)
\\&& A(in|a|out) \quad A(in|b|out)
}

\subsubsection{Parallel Composition}
Here $\#n$ denotes mumblings of length $n$.
\RLEQNS{
   a \parallel b
   &=& [in\mid([\ell_{g1}|\ell_{g1:}],[\ell_{g2}|\ell_{g2:}])\mid out]
\\ &&  A(in|ii|\ell_{g1},\ell_{g2})
       \quad
       A(\ell_{g1:},\ell_{g2:}|ii|out)
       \quad
       A(\ell_{g1}|a|\ell_{g1:})
       \quad
       A(\ell_{g2}|b|\ell_{g2:}) &
\\ && A(in|a|\ell_{g1:},\ell_{g2})
      \quad
      A(\ell_{g1},\ell_{g2}|b;a|\ell_{g1:},\ell_{g2:})
      \quad
      A(in|b|\ell_{g2:},\ell_{g1}) & \#2
\\ && A(\ell_{g1},\ell_{g2}|a ; b|\ell_{g1:},\ell_{g2:})
      \quad
      A(\ell_{g2:},\ell_{g1}|a|out)
      \quad
      A(\ell_{g1:},\ell_{g2}|b|out) & \#2
\\ && A(in|b;a|\ell_{g1:},\ell_{g2:})
      \quad
      A(in|a;b|\ell_{g1:},\ell_{g2:}) & \#3
\\ && A(\ell_{g1},\ell_{g2}|b;a|out)
      \quad
      A(\ell_{g1},\ell_{g2}|a;b|out) & \#3
\\ && A(in|b;a|out)
      \quad
      A(in|a;b|out) & \#4
}

\subsubsection{Non-deterministic Iteration}
The actions that denote a terminating
run with zero or more complete iterations
are \textbf{emboldended} below.
\RLEQNS{
   a^*
   &=& [in|\ell_g|out]
\\ &&  \mathbf{A(in|ii|out)} \quad A(in|ii|\ell_g) \quad A(\ell_g|a|in)
\\ &&  A(\ell_g|a|out) \quad A(\ell_g|a|\ell_g) \quad A(in|a|in)         &\#2
\\ &&  \mathbf{A(in|a|out)} \quad A(in|a|\ell_g) \quad A(\ell_g|a^2|in)  &\#3
\\ &&  A(\ell_g|a^2|out) \quad A(\ell_g|a^2|\ell_g) \quad A(in|a^2|in)   &\#4
\\ &&  \mathbf{A(in|a^2|out)} \quad A(in|a^2|\ell_g) \quad A(\ell_g|a^3|in) &\#5
\\ &&  A(\ell_g|a^3|out) \quad A(\ell_g|a^3|\ell_g) \quad A(in|a^3|in) &\#6
\\ && \vdots & \#7\dots
}
An obvious recurrent pattern (based on mumbling depth) has emerged:
\RLEQNS{
   &&  \mathbf{A(in|a^n|out)} \quad A(in|a^n|\ell_g) \quad A(\ell_g|a^{n+1}|in) &\#2n+1
\\ &&  A(\ell_g|a^{n+1}|out) \quad A(\ell_g|a^{n+1}|\ell_g) \quad A(in|a^{n+1}|in) &\#2n+2
}
We can also identify a pattern based on number of $a$s performed:
\RLEQNS{
   \alpha_0 && \mathbf{A(in|ii|out)} \quad A(in|ii|\ell_g)
\\ \alpha_1 && A(\ell_g|a|in) \quad A(\ell_g|a|out) \quad A(\ell_g|a|\ell_g) \quad A(in|a|in)
\\          && \mathbf{A(in|a|out)} \quad A(in|a|\ell_g)
\\ \alpha_2 && A(\ell_g|a^2|in) \quad A(\ell_g|a^2|out) \quad A(\ell_g|a^2|\ell_g) \quad A(in|a^2|in)
\\          && \mathbf{A(in|a^2|out)} \quad A(in|a^2|\ell_g)
\\
\\ \alpha_n && A(\ell_g|a^n|in) \quad A(\ell_g|a^n|out) \quad A(\ell_g|a^n|\ell_g) \quad A(in|a^n|in)
\\          && \mathbf{A(in|a^n|out)} \quad A(in|a^n|\ell_g)
}
