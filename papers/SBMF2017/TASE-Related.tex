\section{Related Work}\label{ha:related}


\subsection{Process Semantics}

Our motivation for wanting to formalise PML
comes from its applicability in modelling clinical healthcare pathways
\cite{Campbell98}
in particular,
as well as its use to model certified medical software development processes.
Clinical pathways are evidence-based care plans which describe in a
structured way the essential steps needed to care for patients with a
specific set of clinical problems.





Formalisms that model CPs, need to be able to 'reason' with process behaviour
such as non-determinism, concurrency, parallelism and synchronisation. The
affinity of the Petri nets formalism to represent such behaviour has
contributed to its popularity to be used in the more 'formal spectrum' of CPs
research. Petri nets have been used to model such work-flows
\cite{Ellis95,vanderAalst96,Eshuis03}.
Stochastic treatments are popular
for looking at resource and time estimation, e.g. ICPA\cite{Yang12}.

A key issue with any attempt to model such pathways is the need
to allow flexibility in how they are actually implemented.
Work by van der Aalst et al \cite{vanderAalst06} proposes an approach (based on Petri
nets) to allow the ability to distinguish between
 marginally different and completely different processes.
Work looking for temporal similarity
using ad hoc temporal constraint networks,
has been reported in \cite{Combi09}.
Other approaches include the use of fuzzy logic \cite{Adam05}
or linear temporal logic expressions \cite{Pesic06}.
Of interest is the work of Grigori et al \cite{Grigori01}
that use the concept of anticipation which allows
the execution of sequential tasks to overlap at the discretion of work-flow
users where there are not specific data dependencies between them.

Some interesting recent work using BPMN\cite{DBLP:conf/caise/GiacomoDMM15}
addresses the same issue that we do,
namely being able to be flexible regarding how models get enacted.
This paper looks at the boundary between strict imperative BPMN
and declarative notations such as Declare\cite{DBLP:conf/edoc/PesicSA07}.
These correspond to our Strict and Weak semantics.
They introduce BPMN-D and give its semantics by translation
to plain BPMN, whose semanitcs is based on Petri-Nets\cite{DBLP:journals/infsof/DijkmanDO08}.


\subsection{Concurrency Semantics}

Key work was done on concurrent semantics in the 80s and 90s,
with a strong focus on fully abstract denotational
semantics.
Notable work form this period includes that by
Stephen Brookes\cite{DBLP:journals/iandc/Brookes96}
and Frank de Boer and colleagues\cite{DBLP:conf/concur/BoerKPR91}.
Both looked at denotations based on the notion of sets of transition traces,
these being sequences of pairs of before-after states.
In order to get compositionality the traces of any program fragment
had to have arbitrary ``stuttering'' and ``mumbling'' state-pairs
added to capture the notion of outside interference.
Full abstraction meant that the semantics had to identify
programs like $skip\lseq skip$ with $skip$,
while distinguishing between $x:=2$ and $x:=1\lseq x:=x+1$.
This latter aspect required the language to be augmented with
an atomic wrapper construct.
A common feature of both was the very close linkage of the denotational
semantics to the operational one.
The work of Brookes\cite{DBLP:journals/iandc/Brookes96}
focussed on imperative languages with fair schedulers,
while that of de Boer et.al\cite{DBLP:conf/concur/BoerKPR91}
looked at a general framework (``failures of failures'')
that covered not just imperative programs
but also constraint solving systems
and \emph{asynchronous} versions of process algebras.


As already stated earlier,
the key inspiration and starting point for the work presented here
was the UTPP paper\cite{DBLP:conf/icfem/WoodcockH02}.
This combined guarded commands\cite{1976:book:dijkstra}
with the idea of action systems\cite{PODC::BackK1983},
interpreted in UTP as non-deterministic choice
over guarded atomic actions,
where disabled actions behave like the unit for that choice.
This basic lattice-theoretic architecture for the UTPP semantics
forms the foundation for the UTCP semantics presented here.
