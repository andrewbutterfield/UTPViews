\section{Labels}\label{sec:labels}

With the notable exception of denotational semantics
in the vein of \cite{DBLP:conf/lics/Brooks93},
most formal semantic analysis of shared-variable concurrency
involves each program statement being labelled.
You see this, for example, in the various techniques for proving correctness
of mutual-exclusion algorithms \cite{MUTEXPROOFS},
as well as in the work on UTPP \cite{DBLP:conf/icfem/WoodcockH02}.
In most cases, the labels are added ``by-hand''
to the interesting partsof the code,
or are a mandatory part of the syntax of the language under consideration.
Our semantic approach here is no different to the above with respect to
the need for labels,
but we differ by:
not requiring any labels in the language;
and generating them automatically
in a way that supports compositional reasoning within the UTP framework.

Given some notion of labels ($l \in Lbs$),
we want a notion of a generator ($g \in Gen$) that supports two operations:
$new:Gen \fun Lbl \times Gen$ produces a new label and a new generator;
while
$split:Gen \fun Gen \times Gen$ splits a generator into two new ones.
In all cases we require that any labels obtained from generators
will not have been obtained previously from any of their parent generators.

To avoid long nested calls of $new$, $split$ and projections $\pi_1,\pi_2$,
we define the following terse label and generator expression syntax:
\RLEQNSs{
   g \in GVar && \text{Generator variables}
\\ G \in GExp &::=& g \mid G_{:} \mid G_1 \mid G_2
\\ L \in LExp &::=& \ell_G
}
Here $G_{:}$ denotes the generator left once $new$ has been run on $G$,
with $\ell_G$ denoting the label so generated.
Expressions $G_1$ and $G_2$ denote the two outcomes of applying $split$ to $G$.
We use $labs(G)$ to denote all the labels that $G$ can generate
and we require the following laws to hold:
\RLEQNSs{
   labs(G) &=& \setof{\ell_G} \cup labs(G_{:}) \cup labs(G_{1}) \cup labs(G_{2})
\\ \ell_G &\notin& labs(G_{:})
\\ \emptyset  &=& labs(G_{1}) \cap labs(G_{2})
}
The simplest model for a generator that satisfies the above constraints
is one that represents the label $\ell_G$ by the expression $G$ itself.
The reason for this shorthand is that without it we would have to write
something like the following
\begin{equation*}
\pi_1(new(\pi_2(new(\pi_2(split(\pi_2(new(\pi_1(split(g)))))))))).
\end{equation*}
instead of $\ell_{g1:2:}$.
This notation is compact, and may appear very contrived.
However it has one very strong advantage:
it makes generators and their labels ``relocatable'',
in much the same way as some program code can be so considered.
The variable $g$ can be viewed as a sort of ``base'',
with all of the labels generated from it being relative to that base.
We can do this, in one way only, by substituting any generator expression
for $g$. If we replace $g$ with something different,
then we ``shift'' all the associated labels accordingly.
If $\gamma$ and $\sigma$ range over sequences of $:$, $1$ and $2$, then
\begin{equation}
   (\ell_{g\gamma})[g\sigma/g]  = \ell_{g\sigma\gamma}
\end{equation}
In effect the substition ``relocates'' generator $g$ by running $new$
and $split$ on it as specified by $\sigma$,
and any labels are in effect generated by this relocated generator using
their $\gamma$ specification.
This simple use of substitution gives us a really easy way to compose
program fragments in terms of their semantics.
