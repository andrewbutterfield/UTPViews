\section{Labels}\label{sec:labels}

In order to manage flow-of-control,
we need to be able to identify when every construct starts,
is running, and ends.
In some approaches in the literature, the program syntax
allows for and requires explicit labels which are used for this purpose.
In our semantics, and that in \cite{DBLP:journals/cacm/Lamport15a},
these identifying labels are generated in a systematic way from
the abstract syntax tree.
We adopt the idea from \cite{DBLP:conf/icfem/WoodcockH02} that flow of control is managed by an auxiliary variable whose value is the
set of all labels of constructs that are able to execute.


We adopted the idea of a label-generator
Given some notion of labels ($l \in Lbs$),
we want a notion of a generator ($g \in Gen$) that supports two operations:
$new:Gen \fun Lbl \times Gen$ that produces a new label and a new generator;
while
$split:Gen \fun Gen \times Gen$ splits a generator into two new ones.
In all cases we require that any labels obtained from new generators
will not have been obtained previously from any of their parent generators.

To avoid long nested calls of $new$, $split$ and projections $\pi_1,\pi_2$,
we define the following terse label and generator expression syntax:
\RLEQNSs{
   g \in GVar && \text{Generator variables}
\\ G \in GExp &::=& g \mid G_{:} \mid G_1 \mid G_2
\\ L \in LExp &::=& \ell_G
}
Here $G_{:}$ denotes the generator left once $new$ has been run on $G$,
with $\ell_G$ denoting the label so generated.
Expressions $G_1$ and $G_2$ denote the two outcomes of applying $split$ to $G$.
We use $labs(G)$ to denote all the labels that $G$ can generate
and we require the following laws to hold:
\RLEQNSs{
   labs(G) &=& \setof{\ell_G} \cup labs(G_{:}) \cup labs(G_{1}) \cup labs(G_{2})
\\ \ell_G &\notin& labs(G_{:})
\\ \emptyset  &=& labs(G_{1}) \cap labs(G_{2})
}
The simplest model for a generator that satisfies the above constraints
is one that represents the label $\ell_G$ by the expression $G$ itself.
The reason for this shorthand is that without it we would have to write
something like the following%
\footnote{``
split $g$, take the first one,
generate a label and take the resulting
generator, split it and take the second,
take two new labels and give me the last one
''}
\begin{equation*}
\pi_1(new(\pi_2(new(\pi_2(split(\pi_2(new(\pi_1(split(g)))))))))).
\end{equation*}
instead of $\ell_{g1:2:}$
.
This notation is compact, and may appear very contrived.
However it has one very strong advantage:
it makes generators and their labels ``relocatable'',
in much the same way as some program code can be so considered.
The variable $g$ can be viewed as a sort of ``base'',
with all of the labels generated from it being relative to that base.
We can do this, in one way only, by substituting any generator expression
for $g$. If we replace $g$ with something different,
then we ``shift'' all the associated labels accordingly.
If $\gamma$ and $\sigma$ range over sequences of $:$, $1$ and $2$, then
\begin{equation}
   (\ell_{g\gamma})[g\sigma/g]  = \ell_{g\sigma\gamma}
\end{equation}
In effect the substitution ``relocates'' generator $g$ by running $new$
and $split$ on it as specified by $\sigma$,
and any labels are in effect generated by this relocated generator using
their $\gamma$ specification.
This simple use of substitution gives us a really easy way to compose
program fragments in terms of their semantics.
In fact this ability to ``relocate'' is how
we manage Lamport's principle that we must be able to talk about command $C$ in the context of an enclosing construct.
