\section{Labels}\label{sec:labels}

In the work on UTPP \cite{DBLP:conf/icfem/WoodcockH02},
the programs were required to have labels in certain places.
Our semantic approach here is no different to the above with respect to
the need for labels,
but we generate them automatically
in a way that supports compositional reasoning within the UTP framework.

Given some notion of labels ($l \in Lbs$),
we want a notion of a generator ($g \in Gen$) that supports two operations:
$new:Gen \fun Lbl \times Gen$ that produces a new label and a new generator;
while
$split:Gen \fun Gen \times Gen$ splits a generator into two new ones.
In all cases we require that any labels obtained from new generators
will not have been obtained previously from any of their parent generators.

To avoid long nested calls of $new$, $split$ and projections $\pi_1,\pi_2$,
we define the following terse label and generator expression syntax:
\RLEQNSs{
   g \in GVar && \text{Generator variables}
\\ G \in GExp &::=& g \mid G_{:} \mid G_1 \mid G_2
\\ L \in LExp &::=& \ell_G
}
Here $G_{:}$ denotes the generator left once $new$ has been run on $G$,
with $\ell_G$ denoting the label so generated.
Expressions $G_1$ and $G_2$ denote the two outcomes of applying $split$ to $G$.
We use $labs(G)$ to denote all the labels that $G$ can generate
and we require the following laws to hold:
\RLEQNSs{
   labs(G) &=& \setof{\ell_G} \cup labs(G_{:}) \cup labs(G_{1}) \cup labs(G_{2})
\\ \ell_G &\notin& labs(G_{:})
\\ \emptyset  &=& labs(G_{1}) \cap labs(G_{2})
}
The simplest model for a generator that satisfies the above constraints
is one that represents the label $\ell_G$ by the expression $G$ itself.
The reason for this shorthand is that without it we would have to write
something like the following
\begin{equation*}
\pi_1(new(\pi_2(new(\pi_2(split(\pi_2(new(\pi_1(split(g)))))))))).
\end{equation*}
instead of $\ell_{g1:2:}$.
This notation is compact, and may appear very contrived.
However it has one very strong advantage:
it makes generators and their labels ``relocatable'',
in much the same way as some program code can be so considered.
The variable $g$ can be viewed as a sort of ``base'',
with all of the labels generated from it being relative to that base.
We can do this, in one way only, by substituting any generator expression
for $g$. If we replace $g$ with something different,
then we ``shift'' all the associated labels accordingly.
If $\gamma$ and $\sigma$ range over sequences of $:$, $1$ and $2$, then
\begin{equation}
   (\ell_{g\gamma})[g\sigma/g]  = \ell_{g\sigma\gamma}
\end{equation}
In effect the substition ``relocates'' generator $g$ by running $new$
and $split$ on it as specified by $\sigma$,
and any labels are in effect generated by this relocated generator using
their $\gamma$ specification.
This simple use of substitution gives us a really easy way to compose
program fragments in terms of their semantics.
