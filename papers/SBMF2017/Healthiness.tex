\section{Healthiness}\label{sec:health}


\subsubsection{Wheels-within-Wheels}\label{ssec:WwW}

The key intuition behind this compositional semantics was to take the
top-level $run$ function of the action-system based semantic model used in UTPP,
and drive it inwards to every level of the program.
The original $run$ can be defined in the context of this theory as
\[
  run(P) = ls := \setof{in} ; \lnot (out \in ls) * P
\]
However this failed to keep atomic components ``live''.
They could never be re-executed,
as would be required if they were within an iteration.
Instead it was realised that every construct (atomic and composite)
would have to be within an infinite loop.%
\RLEQNS{
    \true * P &\elabel{WWW-as-loop}
}%
This wrapping of the basic property in an infinite loop
would occur at every level of the program hierarchy,
hence the our use of the phrase ``Wheels within Wheels''
(WwW) to refer to this principle.

It should be noticed that this theory underwent
a large enumber of iterations before the WwW principle was finally
elucidated properly and shown to give the right results.
Earlier work in this area, reported in \cite{conf/tase/BMN16},
still had $run$ as shown above and was not fully compositional.
The number and complexity of the test calculations needed to debug,
develop and validate the theory presented in this paper
necessitated the develoment of a bespoke ``UTP Calculator''\cite{DBLP:conf/utp/Butterfield16}.

This bold step turns out to be remarkably effective,
with some quite counter-intuitive outcomes.
However it does depend on a specific tweak to the
definition of an atomic action.
In effect we define an atomic action
as placing a basic action inside such a loop,
but within a non-deterministic choice between it
and a \emph{stuttering} step, denoted by UTP's \emph{semantic} skip ($\Skip$):
\RLEQNS{
  \catom a &=& \true * (\Skip \lor A(in|a|out))
\\ \Skip &=& s'=s \land ls'=ls
}
A result of this is that this stuttering step gets
propagated up to enclosing composites,
so in effect we see $\true * C = \true * (\Skip\lor C)$
where $C$ is any predicate denoting the semantics of a command.
Given that our loop bodies always have such a disjunction,
it then becomes interesting to ask what this looks like:
\RLEQNS{
  \true * (\Skip \lor P) &=& \bigvee_{i \in \Nat} P^i
  & \elabel{loop-as-NDC}
}
We find that such a loop is equivalent to a non-deterministic
choice over the number of times that $P$ is repeated,
including zero.

We choose to \emph{define} the healthiness condition as
this large choice.
\RLEQNS{
   P^0 & \defs& \Skip           & \elabel{seq-0}
\\ P^{i+1} & \defs& P \seq P^i  & \elabel{seq-i-plus-1}
\\ \lhsWWW &\defs& \rhsWWW & \elabel{\lblWWW}
}
We note explicitly here that, in effect, our semantic model is based on
unbounded non-determinism.


\subsection{Label-Set Invariants}


The semantics we propose here depends on the careful management
of when specific labels are, or are not,
present in the global label-set $ls$.
Key to the success of this semantics is a collection of label-set invariants
which characterise proper label-set contents,
which are preserved by all label-set manipulations performed
by our semantic definitions.
We have two kinds of invariants,
both of which are concerned with the mutual disjointness, in some sense,
of a collection of sets of labels.
We introduce some shorthand notations to avoid excessively long predicates and expressions. We use `$\mid$' as a seperator between things mean to be disjoint,
and commas to list subsets and/or set- elements that should be unioned together.
So the following fragment
\[  A,b | M,N | x,Y \]
is shorthand for
\[ A \cup \setof a
  \quad \textbf{disjoint-from} \quad
  M \cup N
  \quad \textbf{disjoint-from} \quad
 \setof x \cup Y
\]
To assert mutual set disjointness,
use the following shorthand, where the $L_i$ are label-sets,
\RLEQNS{
   \setof{L_1|L_2|\dots|L_n}
   &\defs&
   \forall_{i,j \in 1\dots n}
    @
    i \neq j \implies L_i \cap L_j = \emptyset
\\ \multicolumn{3}{c}{\elabel{short-disj-lbl}}
}
We also want to assert that certain sets, necessarily mutually disjoint,
can never have any of their elements in the global label-set,
if any element from one of the other sets is present.
Again, we have a shorthand:
\RLEQNS{
   ~[L_1|L_2|\dots|L_n]
   &\defs&
   \forall_{i,j \in 1\dots n}
    @
    i \neq j \implies
     ( L_i \cap ls \neq \emptyset \implies L_j \cap ls = \emptyset )
\\ \multicolumn{3}{c}{\elabel{short-lbl-exclusive}}
}

The first invariant we have, Disjoint Labels ($DL$) is simply one that asserts,
for every construct, that $in$, $out$ and the labels of $g$
are all different.
\footnote{The theory can be developed using only $g$ as a static observation,
and letting $\ell_g$ and $\ell_{g:}$ play the role of $in$ and $out$
respectively, in which case Disjoint Labels is automatically satisfied.
However, while this results in an entirely equivalent theory,
it is notationally more obscure
making it harder to interpret and check.
}%
\RLEQNS{
   DL &\defs& \setof{in|labs(g)|out}  \ecite{Disjoint-Labels}
}
We also need stronger Label Exclusivity invariants,
regarding which labels can, or cannot,
occur in the global label set at any one time.
There is not one such invariant,
but rather we have that each language construct defines its own
variation, in order to ensure that flow of control is correctly managed.

There is a general version of the invariant ($LE$) that holds
for all language constructs that asserts that any point in time,
only elements from of one of $in$, $labs(g)$ or $out$
can be present in $ls$ at any point in time:
\RLEQNS{
   LE &\defs&
   ~[in|labs(g)|out]
   & \ecite{Exclusive-Labels}
}
Note that we also just use a dash to make
the same assertion about the allowable contents of $ls'$
by simply writing $[in|labs(g)|out]'$.'

So, in summary, we have that every healthy predicate describing
a shared-variable concurrent program's behaviour is of the form $\WWW(C)$
for some predicate $C$ and also satisfies $DL$ and maintains $LE$.
