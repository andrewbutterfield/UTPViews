\section{TO DO}\label{ha:TO-DO}

\DRAFT{From original UTCP working document}

\subsection{Designs}

We have exploited the fact that,
for atomic action $A$ with alphabet $\setof{s,s'}$ we have:
$A[f,\ell_1,\ell_2,S/g,in,out,ls] = A$,
which dramatically simplifies the results of various calculations, e.g.:
\RLEQNS{
   run(\A(A) \lseq \A(B))
   &=& (A ; B ) \land ls'=\setof{\ell_{g:}}
\\ run(\A(A) \parallel \A(B))
   &=& ( (A ; B ) \lor (B ; A ) ) \land ls'=\setof{\ell_{g:}}
}
The semantics of $c \wdo \A(A)$ we expect to have a terminating part
and a non-terminating part:
\RLEQNS{
   run(c \wdo \A(A))
   &=& (\bigvee_{i \in \Nat} A^i ) \land \lnot c \land ls'=\setof{\ell_{g:}}
       \lor A^\omega \land c \land \ell_{g:} \notin ls'
\\ \WHERE & & A^0 = s'=s
\\        & & A^{n+1} = A ; A^n
\\        & & A^\omega = \mbox{infinite sequence of $A$s}
}
From the above we can see that a possible interpretation of our semantics as a
Design is
\RLEQNS{
   ok &\defs&  \ell_g \in ls
\\ ok' &\defs&  \ell_{g:} \in ls'
}

\subsection{Healthiness Conditions}

We expect that the following three predicates
are mutually exclusive, but not exhaustive:
\RLEQNS{
   in &\in& ls
\\ out &\in& ls
\\ lab(g) \cap ls &\neq& \emptyset
}
where $in$, $out$, $g$ and $ls$ are in the alphabet.

What other healthiness conditions are there?
How does it all connect to a theory of designs?
Should atomic state change actions be considered as designs?

We can define some program predicates as follows:
\RLEQNS{
   justStarted(P)
   &\defs&
   in \in ls
\\ running(P)
   &\defs&
   \setof{in,out} \cap ls = \emptyset
   \land
   \exists \ell \in ls @ \ell \in labs(g)
\\ justStopped(P) &\defs& out \in ls
}
Note that $running(\A(A)$ is always false.

How useful are these for reasoning?


\subsection{Laws}

We posit the following laws:
\RLEQNS{
   P \lseq ( Q \lseq R) &=& ( P \lseq Q ) \lseq R
   & \elab{$\lseq$-assoc}{;;-assoc}
\\ Idle \lseq P &=& P & \elab{$\lseq$-l-unit}{;;-l-unit}
\\ P \lseq Idle &=& P & \elab{$\lseq$-Q-unit}{;;-r-unit}
\\ P \parallel Q &=& Q \parallel P & \elab{$\parallel$-comm}{||-comm}
\\ P \parallel ( Q \parallel R) &=& ( P \parallel Q ) \parallel R
   & \elab{$\parallel$-assoc}{||-assoc}
\\ P \lcond{true} Q &=& P & \elab{$\lcond{true}$}{lcond-true}
\\ P \lcond{false} Q &=& Q & \elab{$\lcond{false}$}{lcond-false}
\\ c \wdo P &=& (P \lseq c \wdo P) \lcond c Idle
   & \elab{$\wdo$-unroll}{wdo-unroll}
}
The important question here is what do we mean by ``$=$''?
It looks like it asserts the existence of a label bijection,
that respects generators in some sense.

Perhaps we need to introduce the idea of a label relation, induced
as follows:
\RLEQNS{
   \ell_1 &\mapsto_A& \ell_2& \textbf{given } \A(A)[\ell_1,\ell_2,\ldots/in,out,\ldots]
\\ \ell_1 &\mapsto& \ell_2,\ell_3
   & \textbf{given } Split(\ell_2,\ell_3)[\ell_1,\ldots/in,\ldots]
\\ \ell_1,\ell_2 &\mapsto& \ell_3
   & \textbf{given } Merge(\ell_1,\ell_2)[\ell_3,\ldots/out,\ldots]
\\ \ell_1 &\mapsto_{c}& \ell_2
    & \textbf{given } Cond(\ell_2,c,\_)[\ell_1,\ldots/in,\ldots]
\\ \ell_1 &\mapsto_{\lnot c}& \ell_3
    & \textbf{given } Cond(\_,c,\ell_3)[\ell_1,\ldots/in,\ldots]
}
The bijection would need to respect this relation,
which is beginning to look like an operational semantics!


\subsection{STOP PRESS !!!}

It looks like I can do a proper fully compositional semantics after all!!

\RLEQNS{
   \WW(P) &\defs& \lnot ls(out) * P
\\ P \sqcap \top &=& P
\\ P \land \top &=& \top
\\ \A(A) &\defs& \WW(A \land ls' = ls \ominus (in;out) \cond{ls(in)} \top)
\\ P \lseq Q &\defs& \WW (P[\g{:1},\ell_g/g,out] \sqcap Q[\g{:2},\ell_g/g,in])
\\ P \lcond c Q &\defs& \WW(\ldots)
\\ P \parallel Q &\defs& \WW(\ldots)
\\ c \wdo P &\defs& \WW(\ldots)
}


Wheels within wheels (hence $\WW{}$). Is $\WW{}$ idempotent?
How do procedures fit into all of this?

Laws of UTP?
\RLEQNS{
   c * (c * P) &=?=& c * P
\\ c * (d * P) &=?=& d * (c * P)
\\ c * P ; E &=& c * P ; \lnot c \land Q
}
The last should be true, but the others?
 Is an infinite execution of $\Skip$
equal to $\Skip$?



\subsection{Related Work: S. D. Brookes}

Some touchstone papers in this area are the following three by
Stephen Brookes:
\cite{DBLP:conf/concur/Brookes84},
\cite{DBLP:conf/lics/Brooks93}, and
\cite{DBLP:journals/iandc/Brookes96}.
We shall summarise the denotational results here,
using our notational style.

\subsubsection{Syntax}

\def\bskip{skip}
\def\bseq{\lseq}
\def\bpar{\parallel}
\def\bcond#1{\lcond{#1}}
\def\bdo{\wdo}
\def\bawait{\mathbin{!}}
His programming language has one extra (command) construct --- the await command
which we shall consider as a form of guard

\RLEQNS{
   e,b &\in&  Exp, BoolExp
\\ c \in Cmd
   &::=& \bskip       & \textbf{skip}
\\ & | & i := e       & I:=E
\\ & | & c \bseq c    & C_1;C_2
\\ & | & c \bpar c    & C_1 \parallel C_2
\\ & | & c \bcond b c & \textbf{if }B\textbf{ then }C_1\textbf{ else }C_2
\\ & | & b \bdo c     & \textbf{while }B\textbf{ do }C
\\ & | & b \bawait c  & \textbf{await }B\textbf{ then }C
}
In $b \bawait c$ we require $c$ to be limited to a finite sequence
of assignment and skip.
The \textbf{await} construct is needed to ensure full abstraction.


\subsubsection{Semantics}

It is worth noting the following two examples
that give an idea of what an appropriate semantics should be able to do:
\begin{enumerate}
  \item
     We should be able to deduce that $\bskip = \bskip \bseq \bskip$.
     Some semantcs distinguish these, which is too concrete.
  \item
     In isolation we see  that
     \[
        x:=2 = (x:=1 \bseq x:=x+1)
     \]
     However, in context, these behave differently:
     \[
        x:=2 \bpar x:=2
        \neq
        (x:=1 \bseq x:=x+1) \bpar x:=2
     \]
     The latter can result in $x=3$.
\end{enumerate}


\def\E{\mathcal{E}}
\def\B{\mathcal{B}}
\def\M{\mathcal{M}}
\def\bpre{\sqsubseteq_{\M}}
\def\bequiv{\equiv_{\M}}
\def\spre{\leq_{\M}}
\def\sequiv{=_{\M}}
\def\trans{\rightarrow}
\def\rtrans{\trans^{*}}

Initially semantic functions are defined w.r.t. the operational semantics.
\RLEQNS{
   \E\sem{e} &=& \setof{(s,k) | (e,s) \rtrans k }
\\ \B\sem{b} &=& \setof{(s,t) | (e,s) \rtrans t }
}
The partial correctness behaviour function has signature:
\[
\M : Cmd \fun \power(S \times S)
\]
and clearly maps any command to a relation on before and after states,
with the following pre-order:
\[
 C \bpre C'
 \defs
 \forall s @ \M\sem{C}s \subseteq \M \sem{C'}
\]
and then define equivalence ($\bequiv$) from this.

He observes that $\bequiv$ is not susbtitutive:
\RLEQNS{
    x:=1;x:=x+1             &  \bequiv  & x:=2
\\ (x:=1;x:=x+1) \bpar x:=2 &\not\bequiv& x:=2 \bpar x:=2
}
and then defines a substitutive preorder (and hence equivalence $\sequiv$):
\[
  C \spre C'
  \defs
  \forall P[\cdot] @ P[C] \bpre P[C']
\]

We show only one operational rule --- that for \textbf{await},
that shows its atomic behaviour:
\[
\inferrule%
  {(b,s) \rtrans \\ (c,s) \rtrans (c',s')term}
  {(b \bawait c,s) \trans (\bskip,s')}
\]

\paragraph{Transition Traces}

\def\T{\mathcal{T}}
\def\ClsTrc{\power^\dagger(\Sigma^+)}
\def\tclose#1{\setof{{#1}}^{\dagger}}

Imagine that a command transforms $s$ to $s'$,
in a run where it is interrupted $k$ times:
\[
  (s_0,s'_0)(s_1,s'_1)(s_2,s'_2)\dots(s_k,s'_k)
\]
Here $s=s_0$ and $s'=s'_k$,
and the change from $s'_{i-1}$ to $s_i$
denotes the effect of the $i$th interruption.
If $s_i = s'_{i-1}$ then that interruption was non-interfering.

We can define the traces for a command from the operational semantics as
\RLEQNS{
  \T\sem{C} &=& \setof{(s_0,s'_0)(s_1,s'_1)\dots(s_k,s'_k)}
\\ && \textbf{where }C_0 = C
\\ && (C_i,s_i) \rtrans (C_{i+1},s'_{i+1}, \quad i \in 0 \dots k-1
\\ && (C_k,s_k) \rtrans (C',s'_k)term
\\
\\ \M\sem{C} &=& \setof{(s,s')|(s,s') \in \T\sem{C})}
}
Stuttering:
\[
\alpha\beta \in \T\sem C \implies \alpha(s,s)\beta \in \T\sem C
\]
Mumbling:
\[
\alpha(s,s')(s',s'')\beta \in \T\sem C \implies \alpha(s,s'')\beta \in \T\sem C
\]
Given a set $T$ of transition traces, then $T^\dagger$
is the closure under stuttering and mumbling. Note that $\T\sem C$ is closed.
The set of closed sets of non-empty traces under inclusion
($\ClsTrc$)
is a complete
lattice, bottom being the emptyset, and unions giving l.u.b.s.

Concatenation:
\[
T_1 ; T_2 = \tclose{\alpha\beta | \alpha\in T_1, \beta\in T_2}
\]
Interleaving:
\RLEQNS{
   \alpha\bpar\epsilon &=\setof\alpha=& \epsilon\bpar\alpha
\\ x:\alpha \bpar y:\beta
   &=&
   \setof{x:\gamma | \gamma \in \alpha\bpar y:\beta}
   \cup
   \setof{y:\gamma | \gamma \in x:\alpha\bpar \beta}
\\ T_1\bpar T_2
   &=&
   \bigcup\tclose{\alpha\bpar\beta | \alpha\in T_1, \beta\in T_2}
}
We define $\T\sem B$ for boolean expression $b$ as
$\setof{(s,s) | (b,s) \rtrans true }$


\subsubsection{Denotational Semantics}

\def\TT#1{\T\sem{{#1}}}
\def\override{\oplus}
\def\tpre{\sqsubseteq_{\T}}
\def\tequiv{\equiv_{\T}}
\def\wtrans{\trans^\omega}

Denotations (partial correctness):
\RLEQNS{
   \T &:& Cmp \fun \ClsTrc
\\ \TT{skip} &=& \tclose{(s,s)|s \in S}
\\ \TT{i:=e} &=& \tclose{(s,s\override\maplet i k)|(s,k)\in\E\sem{e}}
\\ \TT{c_1\bseq c_2} &=& \TT{c_1} ; \TT{c_2}
\\ \TT{c_1\bpar c_2} &=& \TT{c_1} \parallel \TT{c_2}
\\ \TT{c_1 \bcond b c_2 } &=& \TT{b} ; \TT{c_1} \cup \TT{\lnot b} ; \TT{c_2}
\\ \TT{b \bawait c} &=& \tclose{(s,s') \in \TT{c} | (s,s) \in \TT{b}}
\\ \TT{b \bdo c} &=& (\TT{b} ; \TT{c})^* ; \TT{\lnot b}
\\ &=& \mu W @ (\TT{b};\TT{c};W \cup \TT{\lnot b})
}

Denotational Pre-order (with induced equivalence $\tequiv$):
\RLEQNS{
   \TT{c}s &=& \setof{s'\alpha | (s,s') \in \TT{c}}
\\ c \tpre c' &=& \forall s @ \TT{c}s \subseteq \TT{c'}s
}

If we allow infinite \emph{fair} traces, then we extend from $\Sigma^+$
to $\Sigma^\infty = \Sigma+ \cup \Sigma^\omega$, adjust closure
accordingly, and only the definition for $\bdo$ changes:
\RLEQNS{
   \TT{b \bdo c}
   &=&
   (\TT{b} ; \TT{c})^* ; \TT{\lnot b}
   \cup
   (\TT{b} ; \TT{c})^\omega
}
This is not the greatest fixed point, whose use results in unfair traces being
included,
and identifies all non-terminating commands,
as gives a theory of total correctness:
\RLEQNS{
\\ \TT{b \bdo c} &=& \nu W @ (\TT{b};\TT{c};W \cup \TT{\lnot b})
\\ \M\sem{c}     &=& \setof{(s,s') | (c,s) \rtrans (c',s')term} \cup {}
\\                && \setof{(s,s') | (c,s) \wtrans \land s' \in S_\bot}
}


\subsubsection{Laws}


Here $=$ and $\sqsubseteq$ correspond to $\tequiv$ and $\tpre$, respectively,
and assuming that assignment is atomic:
\RLEQNS{
   \bskip &=& i:=i
\\ \bskip \bseq c           & = c = & c \bseq skip
\\ (c_1 \bseq c_2) \bseq c_3 &=& c_1 \bseq (c_2 \bseq c_3)
\\ c \bpar \bskip &=& c
\\ c_1 \bpar c_2 &=& c_2 \bpar c_1
\\ (c_1 \bpar c_2) \bpar c_3 &=& c_1 \bpar (c_2 \bpar c_3)
\\ c_1 \bseq (c_2 \bpar c_3) &\sqsubseteq& (c_1 \bseq c_2) \bpar c_3
\\ c_1 \bseq c_2 &\sqsubseteq& c_1 \bpar c_2
\\ (c_1 \bcond b c_2) \bseq c_3 &=& (c_1 \bseq c_3) \bcond c (c_2 \bseq c_3)
\\ c_1 \bcond{b_1 \land b_2} c_2
   &\sqsubseteq&
   (c_1 \bcond{b_2} c_2) \bcond{b_1} c_2
\\ b \bdo c &=& (c \bseq b \bdo c) \cond b \bskip
\\ (b_1 \land b_2) \bawait c &=& b_1 \bawait (b_2 \bawait c)
\\ false \bawait c &\sqsubseteq& c'
\\ false \bawait c &=& true \bdo \bskip
}
If expression evaluation is deterministic:
\RLEQNS{
   i:=e_2[e_1/i] &\sqsubseteq& i:=e_1 \bseq i:=e_2
}
If assignment is \emph{not} atomic:
\RLEQNS{
   \bskip &\sqsubseteq& i:=i
}
If we allow infinite \emph{fair} traces then some of the laws above break/alter as follows:
\RLEQNS{
   c_1 \bseq (c_2 \bpar c_3) &\sqsubseteq& (c_1 \bseq c_2) \bpar c_3
   & \say{only if $c_1$ is loop-free}
\\ false \bawait c &\neq& true \bdo \bskip
\\ true \bdo \bskip &\not\sqsubseteq& c'
}
A loop for $c_1$ in the first case results in inequality because
of the fairness assumption which will force some $c_3$ events to occur
on the rhs, even if $c_1$ is non-terminating,
whereas the lhs will only ever produce $c_1$'s ever-growing trace.

\subsubsection{Other extensions}

\def\bor{\textbf{ or }}

We can add in non-deterministic choice as well:
\RLEQNS{
   \TT{c_1 \bor c_2} &=& \TT{c_1} \cup \TT{c_2}
\\ c \sqsubseteq c' &\equiv& (c \bor c') = c'
\\ i_1:=e_1 \bpar i_2:=e_2
   &=&
   (i_1:=e_1 \bseq i_2:=e_2) \bor (i_2:=e_2 \bseq i_1:=e_1)
}
The latter holding for atomic assignment.

We can also add random assignment easily:
\RLEQNS{
   \TT{i:=?} &=& \tclose{(s,s\override\maplet i k)| s \in S \land k \in \Int}
}

Almost all of the above comes from \cite{DBLP:conf/lics/Brooks93}.
The following can be found in \cite{DBLP:journals/iandc/Brookes96}.

\def\bnew#1#2{\nu {#1}={#2} @}
\def\hide{\backslash}

A new local variable extension:
\RLEQNS{
   c \in Cmd
   &::=& \ldots
\\ & | & \bnew i e c & \textbf{new } I=E\textbf{ in }C
}

We have
state update extension $[s' | i = s(i) ]$ is $s\hide i$ when $i \notin \dom(s)$.
and use $\alpha\hide i$ to replace each $(s_n,s'_n)$ pair in $\alpha$
by $(s_n,[s'_n | i=s_n(i)])$.
In effect this masks any changes in $\alpha$ to $i$, effectively hiding them.

Also,
\RLEQNS{
   <i=k>\beta
   &=& ([s_0|i=k],s'_0),\dots,([s_n|i=s'_{n-1}(i)],s'_n)\dots
\\ && where
\\ && \beta = (s_0,s'_0),\dots,(s_n,s'_n)\dots
}

Semantics:
\RLEQNS{
   \TT{\bnew i e c'}
   &=&
   \tclose{
     \alpha(\beta\hide i)
     | (\alpha,k) \in \TT{e} \land <i=k>\beta \in \TT{c'}
   }
}

Laws:
\RLEQNS{
   \bnew x 0 x:=x+1 &=& \bskip
\\ \bnew i e c &=& c & i \notin \fv c
\\ \bnew i e (c_1 \bseq c_2) &=& c_1 \bseq \bnew i e c_2
   & i \notin \fv{c_1},  updates(c_1) \not\!\cap\; \fv{e}
\\ \bnew i e (c_1 \bpar c_2) &=& c_1 \bpar \bnew i e c_2
   & i \notin \fv{c_1},  updates(c_1) \not\!\cap\; \fv{e}
}

They mention reference [7] (here \cite{DBLP:conf/concur/BoerKPR91})
that has omniscient observations
of every state change - fully abstract but with no fairness.


\subsection{Related Work: Failures of Failures}

\def\L{\mathcal{L}}
\def\ltrans#1{\stackrel{#1}{\rightarrow}}

We look at \cite{DBLP:conf/concur/BoerKPR91}
where an abstract asynchronous communication mechanism
with atomic actions is described,
that can generalise the Brookes work.

It is also based on transition traces as sequences of pairs of states.

\subsubsection{Syntax}
The language ($s,t \in \L$) is
\RLEQNS{
   a &\in& A & \say{Atomic actions}
\\ s &::=& a \mid | s;t | s+t | s \parallel t | E
         & \say{no recursion, $E$ is termination}
}

\subsubsection{Semantics}

Semantic domains
\RLEQNS{
   \sigma &\in & \Sigma & \say{Abstract states}
\\ I &:& A \fun \Sigma \pfun \Sigma
\\ Label &=& \Sigma\times\Sigma
\\ \lambda &\in& Label
\\ \Sigma^+_\delta &=& \Sigma^+ \cup \Sigma^+ \cdot \setof\delta
\\ \Sigma_\delta &=& \Sigma \cup \setof\delta
}
Failures are captured here as traces that end with $\delta$.

They point out that using traces of the form $(\Sigma\times\Sigma)^+$
is more abstract that using $(\Sigma \fun \Sigma)^+$,
because you can identify more sets of the former,
as compared to sets of the latter.

The usual SOS rules apply, with the following definition for atomic actions:
\[
 \inferrule%
  {I(a)(\sigma)\say{ is defined}}
  {a \ltrans{(\sigma, I(a)(\sigma))} E}
\]
An action undefined in the current state simply blocks.

A denotational semantics (composition) is derived from the operational.

\subsubsection{Instantiations}

\paragraph{Imperative Language}

\RLEQNS{
   \Sigma &=& Var \fun Val
\\ I(x:=e)(\sigma)(y)
   &=&
   \left\{
     \begin{array}{ll}
       \sigma(y), & y \neq x \\
       \E(e)(\sigma), & y=x
     \end{array}
   \right.
}

\paragraph{Asynchronous CCS}

\RLEQNS{
   a &\in& Act & \say{Actions}
\\ A &=& Act \cup \overline{Act}
\\ \Sigma &=& \power A
\\ I(a)(\sigma) &=& \sigma \cup\setof a
\\ I(\overline{a})(\sigma)
   &=&
      \left\{
        \begin{array}{ll}
          \sigma, & a \in \sigma \\
          \say{undefined}, & a \notin\sigma
        \end{array}
      \right.
}

\paragraph{Asynchronous CSP}

\RLEQNS{
   x &\in& Var & \say{Variables}
\\ h &\in& IExp & \say{Integer Expr}
\\ b &\in& BExp & \say{Boolean Expr}
\\ c &\in& CName & \say{Channel Names ($\alpha$ in paper)}
\\ A &=& B \cup \setof{c?x} \cup \setof{c!h}
\\ \Sigma &=& \multicolumn{2}{l}{(Var \fun Val)\times(CName \fun Val^*)}
\\ I(b)(\sigma)
   &=&
      \left\{
        \begin{array}{ll}
          \sigma, & \E(b)\sigma=true \\
          \say{undefined}, & \say{otherwise}
        \end{array}
      \right.
\\ I(c!h)(\sigma) &=& \sigma\seqof{\sigma(c).\E(h)(\sigma)/c}
\\ I(c?x)(\sigma)
   &=& \multicolumn{2}{l}{
      \left\{
        \begin{array}{ll}
          \sigma\seqof{head(\sigma(c))/x,tail(\sigma(c))/c}, & \sigma(c)\neq\seqof{} \\
          \say{undefined}, & \say{otherwise}
        \end{array}
      \right.}
}

\subsubsection{Full Abstraction}

There is a notion of complete interpretations,
i.e. for \emph{every} $\sigma$, $\sigma'$ we have an action defined \emph{only} in state
$\sigma$ that results in new state $\sigma'$.
This looks very like the use of/need for \textbf{await} in Brookes work.
