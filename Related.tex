\section{Related Work}\label{sec:related}

The UTP views paper by van Staden\cite{DBLP:conf/utp/Staden14}
starts algebraically, looking at Kleene alebras over languages.
Languages here are sets of strings over an alphabet $A$.
He then takes $A =\Sigma\times\Sigma$,
which in effect encodes the Brookes model\cite{DBLP:journals/iandc/Brookes96}
(see also Park\cite{conf/ac/Park79}).

This paper may provide a way for me to prove all the laws hold for
my formulation of UTCP.


Needed: a description of prior compositional semantics
for shared-variable concurrency,
including Brookes, de Boer, something from actions systems (Mosses?)
and Petri-Nets (?).
Want to explore the role of stuttering and mumbling,
at least in the Brookes and de Boer work.

Glynn Winskel's fibrations as a unification principle?


\subsection{Concurrency Semantics}

Key work was done on concurrent semantics in the 80s and 90s,
with a strong focus on fully abstract denotational
semantics.
Notable work form this period includes that by
Stephen Brookes\cite{DBLP:journals/iandc/Brookes96}
and Frank de Boer and colleagues\cite{DBLP:conf/concur/BoerKPR91}.
Both looked at denotations based on the notion of sets of transition traces,
these being sequences of pairs of before-after states.
In order to get compositionality the traces of any program fragment
had to have arbitrary ``stuttering'' and ``mumbling'' state-pairs
added to capture the notion of outside interference.
Full abstraction meant that the semantics had to identify
programs like $skip\cseq skip$ with $skip$,
while distinguishing between $x:=2$ and $x:=1\cseq x:=x+1$.
This latter aspect required the language to be augmented with
an atomic wrapper construct.
A common feature of both was the very close linkage of the denotational
semantics to the operational one.
The work of Brookes\cite{DBLP:journals/iandc/Brookes96}
focussed on imperative languages with fair schedulers,
while that of de Boer et.al\cite{DBLP:conf/concur/BoerKPR91}
looked at a general framework (``failures of failures'')
that covered not just imperative programs
but also constraint solving systems
and \emph{asynchronous} versions of process algebras.


As already stated earlier,
the key inspiration and starting point for the work presented here
was the UTPP paper\cite{DBLP:conf/icfem/WoodcockH02}.
This combined guarded commands\cite{1976:book:dijkstra}
with the idea of action systems\cite{PODC::BackK1983},
interpreted in UTP as non-deterministic choice
over guarded atomic actions,
where disabled actions behave like the unit for that choice.
This basic lattice-theoretic architecture for the UTPP semantics
forms the foundation for the UTCP semantics presented here.

\subsection{Action Systems}

Here we give a short introduction to semantics of action systems
in UTP, following the material on unifying theories
of parallel programming in \cite{DBLP:conf/icfem/WoodcockH02}.

We assume the UTP theory of designs ($P \design Q$), with definitions
of assignment ($x:=e$),
sequential composition ($P;Q$),
iteration ($c*P$), and assumptions ($c^\top$).

\begin{quote}
``An action system has a state, an initialisation, and a number of actions.
First the initialisation is performed;
then repeatedly, a command whose guard is true is selected and executed.
If several guards are true,
then one of them is selected and its corresponding command is executed''\cite{DBLP:conf/icfem/WoodcockH02}
\end{quote}



We define a guarded action, where $g$ is a condition,
and $P$ a design, as:
\RLEQNS{
     g \rightarrow P &\defs& g^\top ; P & \elabel{def:guard}
}

An action system program
consists of a state declaration ($v$),
initial state ($V_0$)
a continue condition ($cont$),
and a set of guarded actions $\setof{g_i \rightarrow P_i}$.
It initialises the state,
and then, while the continue condition remains true,
repeatedly evaluates the disjunction of all the guarded actions.
\begin{eqnarray*}
(v,V_0,cont,\setof{g_i \rightarrow P_i})
   &\defs&
   \textbf{var }v := V_0 ~;
\\&& cont * \bigvee_i (g_i \rightarrow P_i)
\end{eqnarray*}
